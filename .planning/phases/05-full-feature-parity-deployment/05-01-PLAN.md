---
phase: 05-full-feature-parity-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - streamlit_app/streamlit_app.py
autonomous: true
must_haves:
  truths:
    - "Full design space convex hull renders as light gray semi-transparent background polygon on scatter plot"
    - "31 per-participant convex hulls render as colored semi-transparent filled polygons matching participant colors"
    - "30 per-participant exploration arrows (P_001-P_030, no GALL) show solution sequence with directional arrow markers"
    - "Areas sidebar checkbox (enabled) toggles all hull traces on/off"
    - "Arrows sidebar checkbox (enabled) toggles all arrow traces on/off"
    - "Participant filter controls which hull/arrow traces are visible (only selected participants)"
    - "Creativity metrics (area explored, distance traveled, clusters visited: total/pre/post) display in detail panel"
    - "Novelty metrics (neighbors, density) and solution performance display in detail panel"
    - "GALL solutions show N/A gracefully for participant-level metrics"
  artifacts:
    - path: "streamlit_app/streamlit_app.py"
      provides: "Hull traces, arrow traces, visibility controls, metrics display"
      contains: "load_convex_hulls"
  key_links:
    - from: "show_areas checkbox"
      to: "hull trace.visible"
      via: "visibility loop over traces 0 through N_hulls"
      pattern: "show_areas.*visible"
    - from: "show_arrows checkbox"
      to: "arrow trace.visible"
      via: "visibility loop over arrow traces"
      pattern: "show_arrows.*visible"
    - from: "selected_participants filter"
      to: "hull/arrow trace.visible"
      via: "pt_id in selected_participants check"
      pattern: "in selected_participants"
    - from: "convex_hulls.pkl"
      to: "hull trace x/y"
      via: "load_convex_hulls cached function"
      pattern: "hulls\\[.*\\]\\[.x.\\]"
    - from: "df row metrics"
      to: "detail panel text"
      via: "row['Area-Perc-FS'] etc formatted with fmt_metric helper"
      pattern: "Area-Perc-FS|totaldist_FS|n_clusters|novel_nn|performance"
---

<objective>
Add convex hulls, exploration arrows, visibility controls, and all remaining creativity/novelty/performance metrics to complete feature parity with the original Dash app.

Purpose: The scatter plot currently shows only solution points. The original Dash app overlays convex hulls (showing each participant's explored area), arrows (showing design sequence), and displays comprehensive creativity metrics. These visual layers are essential for the research use case -- they show HOW participants explored the design space, not just where their solutions ended up.

Output: Updated streamlit_app.py with 62 new traces (1 full DS hull + 31 participant hulls + 30 arrow sequences), enabled Areas/Arrows checkboxes, participant-aware visibility filtering, and complete metrics in the detail panel.
</objective>

<execution_context>
@C:/Users/e_par/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/e_par/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@c:/Py/DS_Viz_SL/.planning/PROJECT.md
@c:/Py/DS_Viz_SL/.planning/ROADMAP.md
@c:/Py/DS_Viz_SL/.planning/phases/05-full-feature-parity-deployment/05-RESEARCH.md
@c:/Py/DS_Viz_SL/streamlit_app/streamlit_app.py
@c:/Py/DS_Viz_SL/scripts/interactive_tool.py (lines 228-298 for hull/arrow traces, lines 614-682 for metrics)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add convex hull traces, arrow traces, and wire visibility controls</name>
  <files>streamlit_app/streamlit_app.py</files>
  <action>
Modify streamlit_app.py to add hull/arrow trace layers and enable visibility controls. Follow the original Dash app pattern (interactive_tool.py lines 228-298) with adaptations noted below.

**1. Add load_convex_hulls cached function** (after the existing load_metadata function):
```python
@st.cache_data
def load_convex_hulls():
    import pickle
    with open(DATA_DIR / 'convex_hulls.pkl', 'rb') as f:
        return pickle.load(f)
```
Call it alongside the other data loads: `hulls = load_convex_hulls()`

**2. Add hex_to_rgba helper function** (before figure construction):
```python
def hex_to_rgba(hex_color, alpha):
    h = hex_color.lstrip('#')
    r, g, b = int(h[0:2], 16), int(h[2:4], 16), int(h[4:6], 16)
    return f'rgba({r}, {g}, {b}, {alpha})'
```

**3. Enable the Arrows and Areas checkboxes** by removing `disabled=True` from both checkboxes in the sidebar Display section. Also remove the "(coming in Phase 5)" help text and update to descriptive help:
- Arrows help: "Show exploration sequence arrows per participant"
- Areas help: "Show convex hull areas per participant"

**4. Build hull and arrow traces BEFORE the existing scatter trace** in the figure construction section. The trace order matters for correct layering (hulls behind arrows behind scatter points):

**Trace 0 -- Full DS convex hull (background):**
```python
hull_x = hulls['full_ds']['x'] + [hulls['full_ds']['x'][0]]  # Close polygon
hull_y = hulls['full_ds']['y'] + [hulls['full_ds']['y'][0]]
fig.add_trace(go.Scatter(
    x=hull_x, y=hull_y,
    mode='lines', fill='toself',
    fillcolor='rgba(240,240,240,0.5)',
    line=dict(color='rgba(240,240,240,0.5)', width=0),
    hoverinfo='skip', name='full_ds_hull', showlegend=False,
))
```
IMPORTANT: The pre-computed hull vertices are NOT closed (first point != last point). You MUST append the first point to close the polygon for fill='toself' to work correctly.

**Traces 1-31 -- Per-participant convex hulls:**
Loop over `metadata['participant_ids']` (31 entries: GALL, P_001-P_030). For each:
- Get hull data from `hulls[pt_id]`
- Close polygon: append first x/y to end
- Get color from `metadata['color_mapping'][pt_id]`
- fillcolor = hex_to_rgba(color, 0.1), line color = hex_to_rgba(color, 0.3)
- Add trace with fill='toself', hoverinfo='skip', showlegend=False

**Traces 32-61 -- Per-participant arrow sequences (P_001-P_030 only, no GALL):**
Loop over `metadata['participant_ids'][1:31]` (30 entries). For each:
- Filter df (unfiltered, full df) by OriginalID_PT == pt_id, sort by OriginalID_Sol
- x_vals = pt_data['x_emb'].tolist(), y_vals = pt_data['y_emb'].tolist()
- color from metadata['color_mapping'][pt_id], arrow_color = hex_to_rgba(color, 0.5)
- mode='lines+markers', line=dict(color=arrow_color, width=1)
- marker=dict(symbol='arrow-up', size=8, angleref='previous', color=arrow_color)
- hoverinfo='skip', showlegend=False

**Trace 62 -- Scatter points (existing code):**
The existing scatter trace code stays exactly the same, but it now becomes trace index 62 instead of 0. Keep the existing conditional `if show_points:` logic.

**5. Apply visibility logic AFTER all traces are added to fig, BEFORE rendering.** This replaces the simple `if show_points:` conditional approach. Instead, always add ALL traces unconditionally, then set visibility:

```python
# Full DS hull (trace 0): visible if Areas enabled
fig.data[0].visible = show_areas

# Per-participant hulls (traces 1-31)
for i, pt_id in enumerate(metadata['participant_ids'], start=1):
    fig.data[i].visible = show_areas and (pt_id in selected_participants)

# Arrow sequences (traces 32-61, P_001-P_030 only)
for i, pt_id in enumerate(metadata['participant_ids'][1:31], start=32):
    fig.data[i].visible = show_arrows and (pt_id in selected_participants)

# Scatter points (trace 62): visible if Points enabled
fig.data[62].visible = show_points
```

Remove the old `if show_points:` conditional around the scatter trace -- add it unconditionally now, control with visibility. Also remove the `else: st.info("No elements visible...")` block since visibility is now per-trace. Add a check: if not show_points and not show_areas and not show_arrows, show the info message.

**6. Update click handling** to account for the new trace structure. The scatter trace is now at index 62 (last trace). The existing click detection via `event.selection.point_indices` should still work because it returns indices within the clicked trace, and scatter is the only trace with clickable mode='markers'. However, verify that the `customdata` field with `filtered_to_original` is still correctly mapped.

CRITICAL: The scatter trace must be built from df_filtered (as it is now), but hull/arrow traces are built from the FULL df and ALL hulls (visibility controlled by trace.visible). This means hull/arrow traces show all participants' data but hide non-selected ones, while the scatter trace only contains filtered points. This matches the original Dash app pattern where hulls/arrows are pre-built and toggled.

Wait -- this creates a mismatch. If we always build hull/arrow traces from full data but scatter from filtered data, that's correct because:
- Hulls are pre-computed from ALL data (convex_hulls.pkl), visibility controls which show
- Arrows use full df to get complete sequences, visibility controls which show
- Scatter uses filtered df for performance (fewer points to render) and correct click mapping

This is the right approach.

**7. Handle the "no visible elements" info message.** Replace the old conditional with:
After visibility is applied, check if anything is visible. If not show_points and not show_areas and not show_arrows, show `st.info("No elements visible. Enable Points, Arrows, or Areas in the sidebar.")`.
  </action>
  <verify>
Run syntax check: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -c "import ast; ast.parse(open('streamlit_app/streamlit_app.py').read()); print('Syntax OK')"`. Then run the app: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -m streamlit run streamlit_app/streamlit_app.py --server.headless true` -- app should start without errors. Verify no import errors or trace index errors in terminal output.
  </verify>
  <done>
Scatter plot renders 62 new traces (1 full DS hull + 31 participant hulls + 30 arrow sequences) behind the scatter points. Areas checkbox toggles hull visibility. Arrows checkbox toggles arrow visibility. Participant filter controls which participants' hulls and arrows are visible. Hull polygons are closed and filled. Arrow markers point in the direction of design sequence. Existing click handling and detail panel continue to work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add creativity, novelty, and performance metrics to detail panel</name>
  <files>streamlit_app/streamlit_app.py</files>
  <action>
Extend the detail panel in streamlit_app.py to display all remaining metrics after the existing Core Attributes and Screenshot sections.

**1. Add a fmt_metric helper function** (can be defined inside the detail panel block or at module level):
```python
def fmt_metric(value, decimals=1, suffix=''):
    """Format metric value or return N/A for missing data."""
    if isinstance(value, str) and value == 'N/A':
        return 'N/A'
    try:
        formatted = f"{float(value):.{decimals}f}"
        return f"{formatted}{suffix}"
    except (ValueError, TypeError):
        return 'N/A'
```
This gracefully handles GALL solutions which have 'N/A' for many participant-level metrics.

**2. Add the metrics section** after the Screenshot section (Section 6), still inside the `if st.session_state.selected_point_idx is not None:` block:

```python
# Section 7: Space Exploration / Creativity Metrics (DETL-07, 08, 09, 10, 11)
st.divider()
st.markdown("##### Space Exploration / Creativity Metrics")

# Area explored (DETL-07) - percent of full design space
st.markdown(
    f"**Area explored** | Tot.: {fmt_metric(row['Area-Perc-FS'], 1, '%')} | "
    f"Pre: {fmt_metric(row['Area-Perc-PRE'], 1, '%')} | "
    f"Post: {fmt_metric(row['Area-Perc-POST'], 1, '%')}"
)

# Distance traveled (DETL-08) - sum of distances between consecutive solutions
st.markdown(
    f"**Distance travel.** | Total: {fmt_metric(row['totaldist_FS'], 1)} | "
    f"Pre: {fmt_metric(row['totaldist_PRE'], 1)} | "
    f"Post: {fmt_metric(row['totaldist_PST'], 1)}"
)

# Clusters visited (DETL-09) - unique cluster IDs encountered
st.markdown(
    f"**# Clusters visit.** | Total: {fmt_metric(row['n_clusters'], 0)} | "
    f"Pre: {fmt_metric(row['n_clusters_pre'], 0)} | "
    f"Post: {fmt_metric(row['n_clusters_post'], 0)}"
)

# Novelty (DETL-10) - neighbors count and density-based
st.markdown(
    f"**Novelty** | Neighbors: {fmt_metric(row['novel_nn'], 2)} | "
    f"Density: {fmt_metric(row['novelty_norm'], 2)}"
)

# Performance (DETL-11) - budget efficiency
st.markdown(f"**Solution Performance:** {fmt_metric(row['performance'], 2)}")
```

**3. Column names to use** (verified present in df_base.parquet):
- Area: `Area-Perc-FS`, `Area-Perc-PRE`, `Area-Perc-POST`
- Distance: `totaldist_FS`, `totaldist_PRE`, `totaldist_PST` (note: PST not POST)
- Clusters: `n_clusters`, `n_clusters_pre`, `n_clusters_post`
- Novelty: `novel_nn`, `novelty_norm`
- Performance: `performance`

These column names match exactly what is in the parquet file (verified by data inspection).
  </action>
  <verify>
Run syntax check: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -c "import ast; ast.parse(open('streamlit_app/streamlit_app.py').read()); print('Syntax OK')"`. Verify the column names are referenced correctly by checking they exist in df_base.parquet columns.
  </verify>
  <done>
Detail panel shows all 5 metric groups (area explored, distance traveled, clusters visited, novelty, performance) when a point is selected. GALL solutions display 'N/A' gracefully for participant-level metrics. Metric formatting uses appropriate decimal places (1 for area/distance, 0 for clusters, 2 for novelty/performance).
  </done>
</task>

</tasks>

<verification>
1. App starts without errors: `python -m streamlit run streamlit_app/streamlit_app.py`
2. Scatter plot shows light gray background hull covering all solutions
3. Per-participant colored semi-transparent hull polygons visible (with Areas enabled)
4. Exploration arrows visible between consecutive solutions per participant (with Arrows enabled)
5. Areas checkbox toggles hulls on/off
6. Arrows checkbox toggles arrows on/off
7. Participant filter shows only selected participants' hulls and arrows
8. Clicking a point shows creativity metrics (area, distance, clusters) with total/pre/post
9. Clicking a point shows novelty (neighbors, density) and performance
10. GALL solution click shows N/A for participant-level metrics
11. Existing scatter highlighting and click handling still work
</verification>

<success_criteria>
- 63 traces render on scatter plot (1 full DS hull + 31 participant hulls + 30 arrows + 1 scatter)
- Areas/Arrows checkboxes enabled and functional
- Participant filter controls hull/arrow visibility
- All 5 metric groups display in detail panel
- No regressions: scatter clicking, detail panel, participant filtering all continue to work
- App starts and renders without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-full-feature-parity-deployment/05-01-SUMMARY.md`
</output>
