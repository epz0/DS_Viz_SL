---
phase: 03-filtering-visibility-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - streamlit_app/streamlit_app.py
autonomous: true

must_haves:
  truths:
    - "Participant multi-select dropdown filters scatter plot to show only selected participants"
    - "Points checkbox toggles visibility of scatter points"
    - "Arrows and Areas checkboxes are visible but disabled (future phases)"
    - "Filters and toggles work together -- unchecking Points hides all points even when participants are selected"
    - "Click-to-inspect from Phase 2 still works correctly after filtering"
    - "Status caption shows filtered count (e.g. Showing 450 of 563 solutions from 20 of 31 participants)"
    - "All participants selected and all toggles enabled on first load (no blank chart)"
    - "Deselecting all participants shows warning message instead of empty chart"
  artifacts:
    - path: "streamlit_app/streamlit_app.py"
      provides: "Sidebar controls with participant filter and visibility toggles integrated with existing click handling"
      contains: "st.multiselect"
  key_links:
    - from: "streamlit_app/streamlit_app.py"
      to: "st.sidebar"
      via: "Sidebar widgets defined BEFORE main content to avoid rendering order issues"
      pattern: "st\\.sidebar"
    - from: "streamlit_app/streamlit_app.py"
      to: "df['OriginalID_PT'].isin()"
      via: "Pandas isin filtering on unmasked participant IDs from multiselect"
      pattern: "isin\\(selected_participants\\)"
    - from: "streamlit_app/streamlit_app.py"
      to: "df_filtered index mapping"
      via: "customdata carries original DataFrame index so pointIndex maps correctly after filtering"
      pattern: "customdata"
---

<objective>
Add sidebar filtering and visibility controls to the scatter plot: participant multi-select dropdown filters which points appear, and checkboxes toggle visibility of Points (with Arrows and Areas disabled for future phases).

Purpose: Let researchers focus on specific participants or subsets of the design space without losing the full-dataset context. This is the primary data exploration workflow.
Output: Updated streamlit_app.py with sidebar controls, DataFrame filtering, conditional trace rendering, and correct click handling integration.
</objective>

<execution_context>
@C:/Users/e_par/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/e_par/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-filtering-visibility-controls/03-RESEARCH.md
@.planning/phases/02-single-chart-click-handling/02-01-PLAN.md
@streamlit_app/streamlit_app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sidebar controls and wire DataFrame filtering into existing chart</name>
  <files>streamlit_app/streamlit_app.py</files>
  <action>
Modify `streamlit_app/streamlit_app.py` to add sidebar filtering controls and integrate them with the existing scatter plot and click handling from Phase 2.

**IMPORTANT context for this task:** Phase 2 will have already modified this file to include `plotly_events()`, `st.session_state.selected_point_idx`, a two-column layout (`col_chart, col_detail`), and a detail panel. This task builds ON TOP of that code, not the current Phase 1 version. Read the file at execution time to understand its current state.

**Step 1: Add sidebar controls BEFORE the main content area** (after data loading, before any `st.columns` or chart code):

```python
# Sidebar: Filters and Visibility Controls
with st.sidebar:
    st.header("Filters")

    # Participant multiselect -- use OriginalID_PT (unmasked), NOT ParticipantID (masked)
    # Default: all participants selected so chart is fully populated on first load
    all_participants = metadata['participant_ids']  # 31 entries including GALL
    selected_participants = st.multiselect(
        "Participants",
        options=all_participants,
        default=all_participants,
        help="Filter scatter plot to show only selected participants",
        key='participant_filter'
    )

    st.divider()
    st.header("Display")

    # Element visibility toggles
    show_points = st.checkbox(
        "Points",
        value=True,
        help="Show/hide solution scatter points",
        key='show_points'
    )
    show_arrows = st.checkbox(
        "Arrows",
        value=True,
        help="Exploration sequence arrows (coming in Phase 5)",
        key='show_arrows',
        disabled=True  # Not implemented until Phase 5
    )
    show_areas = st.checkbox(
        "Areas",
        value=True,
        help="Convex hull areas (coming in Phase 5)",
        key='show_areas',
        disabled=True  # Not implemented until Phase 5
    )
```

**Step 2: Filter the DataFrame using OriginalID_PT** (after sidebar, before figure creation):

```python
# Filter data by selected participants
df_filtered = df[df['OriginalID_PT'].isin(selected_participants)]
```

**Step 3: Handle empty states** (before figure creation):

If `df_filtered` is empty (no participants selected), show a warning and skip chart rendering entirely:
```python
if df_filtered.empty:
    st.warning("No data matches current filters. Select at least one participant.")
    st.stop()  # Halt execution -- no chart or detail panel to show
```

If `show_points` is unchecked (and Arrows/Areas are disabled), show an info message and an empty figure:
```python
if not show_points:
    st.info("No elements visible. Enable Points in the sidebar.")
    # Still show empty chart area to maintain layout, but skip trace creation
```

**Step 4: Critical -- fix the pointIndex-to-DataFrame mapping after filtering.**

When the DataFrame is filtered, `plotly_events` returns a `pointIndex` relative to the trace data arrays (0, 1, 2...), NOT the original DataFrame index. Phase 2 uses `df.iloc[idx]` which assumes the full DataFrame. After filtering, `df_filtered.iloc[pointIndex]` would give the correct row from the filtered set, but if the user clicks a point and THEN changes filters, the stored index becomes invalid.

The fix: pass the original DataFrame integer index as `customdata` in the scatter trace, then retrieve it from the click event instead of using `pointIndex`.

In the `go.Scatter` trace creation, add:
```python
customdata=df_filtered.index.tolist(),  # Original DataFrame integer index
```

Then modify the click handling to use `customdata` instead of `pointIndex`:
```python
if selected_points:
    # Use customdata (original df index) instead of pointIndex (filtered position)
    clicked_original_idx = selected_points[0].get('customdata', selected_points[0]['pointIndex'])
    # Validate index is still valid
    if clicked_original_idx is not None and clicked_original_idx < len(df):
        if clicked_original_idx != st.session_state.selected_point_idx:
            st.session_state.selected_point_idx = clicked_original_idx
            st.rerun()
```

IMPORTANT: streamlit-plotly-events may not return `customdata` in the click event dict. If it does not, an alternative approach is needed: store a mapping from filtered position to original index:
```python
filtered_to_original = df_filtered.index.tolist()
# Then in click handler:
clicked_filtered_pos = selected_points[0]['pointIndex']
clicked_original_idx = filtered_to_original[clicked_filtered_pos]
```

Use whichever approach works. Test by: selecting a subset of participants, clicking a point, and verifying the detail panel shows the correct solution (not a different one).

**Step 5: Update the marker highlight logic** (Phase 2's per-point size/symbol arrays).

Phase 2 builds marker arrays checking `st.session_state.selected_point_idx` against each row. After filtering, this loop must iterate over `df_filtered` rows, not the full `df`. The selected point should ONLY be highlighted if it's in the current filtered set. If the selected point was filtered out, the highlight should not appear (no crash, just no highlight).

Build marker arrays from `df_filtered`:
```python
selected_idx = st.session_state.selected_point_idx

sizes = []
symbols = []
line_widths = []
line_colors = []

for orig_idx, row in df_filtered.iterrows():
    if orig_idx == selected_idx:
        sizes.append(18)
        symbols.append('square-x-open')
        line_widths.append(2)
        line_colors.append('black')
    else:
        sizes.append(8)
        symbols.append(row['clust_symb'])
        line_widths.append(0)
        line_colors.append(row['HEX-Win'])
```

Note: `df_filtered.iterrows()` yields `(original_index, row)` pairs because pandas preserves the original index after `.isin()` filtering. So `orig_idx` correctly matches `selected_point_idx`.

**Step 6: Conditionally render the scatter trace based on show_points:**

Wrap the `fig.add_trace(go.Scatter(...))` call in `if show_points:`. When Points is unchecked, create the figure but don't add the scatter trace. The figure layout should still be applied (so the chart area isn't blank, just empty).

**Step 7: Update the status caption** to reflect filter state:

Replace the existing `st.caption(f"Loaded {len(df)}...")` with:
```python
st.caption(
    f"Showing {len(df_filtered):,} of {len(df):,} solutions "
    f"from {len(selected_participants)} of {len(all_participants)} participants"
)
```
Place this below the chart, before or after the detail panel column.

**Step 8: Clear selection when filtering removes the selected point.**

After filtering, check if the currently selected point is still in the filtered set. If not, clear the selection:
```python
if st.session_state.selected_point_idx is not None:
    if st.session_state.selected_point_idx not in df_filtered.index:
        st.session_state.selected_point_idx = None
```
Place this after `df_filtered` is created but before marker arrays are built.

**Summary of integration points with Phase 2 code:**
- Sidebar widgets go BEFORE the two-column layout
- `df_filtered` replaces `df` in ALL trace creation and marker array code
- `filtered_to_original` index mapping replaces direct `pointIndex` usage in click handler
- Detail panel continues using `df.iloc[selected_point_idx]` (original full DataFrame) since `selected_point_idx` stores the original index
- Status caption updates from static to dynamic
  </action>
  <verify>
Run the app locally:
```
/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -m streamlit run streamlit_app/streamlit_app.py
```

Verify all of the following:

1. **First load:** All 563 points visible, sidebar shows all 31 participants selected, Points checked, Arrows/Areas checked but grayed out (disabled)
2. **Filter by participant:** Deselect several participants -- scatter updates to show fewer points, caption updates count
3. **Deselect all:** Warning message appears, no chart errors
4. **Toggle Points off:** Points disappear from chart, info message shown
5. **Toggle Points back on:** Points reappear
6. **Click a point:** Detail panel shows correct solution info (same as Phase 2)
7. **Filter after clicking:** Select a subset that excludes the clicked point -- selection clears, detail panel shows "Click a point..." message
8. **Click after filtering:** Click a point in filtered view -- detail panel shows the CORRECT solution (not a different one due to index mismatch)
9. **Arrows/Areas checkboxes:** Visible but cannot be clicked (disabled)
10. **Status caption:** Shows "Showing X of 563 solutions from Y of 31 participants"
  </verify>
  <done>
Sidebar with participant multi-select (FILT-01) and visibility checkboxes (FILT-02) controls the scatter plot. Filters and toggles work together (FILT-03): deselecting participants removes their points, unchecking Points hides the scatter trace. Click-to-inspect from Phase 2 works correctly with filtered data -- clicking a point after filtering shows the correct solution details. Status caption reflects current filter state. Empty states handled gracefully.
  </done>
</task>

</tasks>

<verification>
Phase-level verification after task completes:

1. **FILT-01 (Participant filter):** Open sidebar, deselect 5 participants -- scatter plot updates to show only solutions from selected participants. Reselect all -- full dataset returns.

2. **FILT-02 (Element toggles):** Uncheck "Points" -- scatter points disappear. Recheck -- they return. "Arrows" and "Areas" checkboxes are visible but grayed out and non-interactive.

3. **FILT-03 (Combined):** Select only 3 participants AND have Points enabled -- only those 3 participants' points show. Uncheck Points -- chart goes empty. Re-check Points -- 3 participants' points return.

4. **Click integration regression:** With a participant subset selected, click a point -- detail panel shows the correct solution's info, screenshot loads, highlight appears on the correct point.

5. **Index integrity:** Click point in full dataset, note solution ID. Filter to single participant containing that solution. Verify the same point still shows the same solution details. Then filter to a different participant -- selection should clear.

6. **Default state:** On fresh load (or after clearing cache), all participants selected, all checkboxes enabled (Arrows/Areas disabled), full 563 points displayed.
</verification>

<success_criteria>
- Sidebar controls render with participant multiselect and three visibility checkboxes
- Multiselect defaults to all 31 participants; filtering reduces visible points correctly
- Points checkbox toggles scatter trace visibility
- Arrows and Areas checkboxes visible but disabled (greyed out)
- Click handling works correctly with filtered data (correct solution shown in detail panel)
- Status caption dynamically reflects filter state
- Empty filter state shows warning without errors
- No regressions to Phase 2 click handling, detail panel, or screenshot loading
</success_criteria>

<output>
After completion, create `.planning/phases/03-filtering-visibility-controls/03-01-SUMMARY.md`
</output>
