---
phase: 04-performance-chart-cross-chart-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - streamlit_app/streamlit_app.py
autonomous: true
must_haves:
  truths:
    - "Performance chart displays 30 participant traces (P_001-P_030) as lines+markers with per-participant colors"
    - "Horizontal dotted reference line at y=1 visible in performance chart"
    - "Clicking scatter point isolates that participant's trace in performance chart and highlights the clicked solution marker"
    - "Vertical dashed intervention line appears at pre/post boundary for selected participant"
    - "Clicking performance chart point highlights the corresponding solution in the scatter plot"
    - "Detail panel updates correctly regardless of which chart was clicked"
    - "GALL solutions hide all performance traces when clicked"
  artifacts:
    - path: "streamlit_app/streamlit_app.py"
      provides: "Performance chart construction, bidirectional click sync, updated layout"
      contains: "fig_perf"
  key_links:
    - from: "scatter plotly_events click"
      to: "performance chart trace isolation"
      via: "session_state.selected_participant drives trace visibility"
      pattern: "selected_participant.*visible"
    - from: "performance plotly_events click"
      to: "scatter marker highlighting"
      via: "session_state.selected_point_idx drives marker arrays"
      pattern: "selected_point_idx.*marker_sizes"
    - from: "either chart click"
      to: "detail panel"
      via: "session_state.selected_point_idx used by detail panel rendering"
      pattern: "df\\.iloc\\[.*selected_point_idx"
---

<objective>
Add performance chart with bidirectional click synchronization to the scatter plot.

Purpose: Users need to see how a participant's solutions perform over time (budget efficiency) and click either chart to explore â€” clicking scatter highlights the solution in the performance chart, clicking performance chart highlights in the scatter plot. Both update the detail panel.

Output: Updated streamlit_app.py with stacked scatter+performance charts on left, detail panel on right, bidirectional click handling via session state.
</objective>

<execution_context>
@C:/Users/e_par/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/e_par/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@c:/Py/DS_Viz_SL/.planning/PROJECT.md
@c:/Py/DS_Viz_SL/.planning/ROADMAP.md
@c:/Py/DS_Viz_SL/.planning/phases/04-performance-chart-cross-chart-sync/04-RESEARCH.md
@c:/Py/DS_Viz_SL/.planning/phases/02-single-chart-click-handling/02-01-SUMMARY.md
@c:/Py/DS_Viz_SL/streamlit_app/streamlit_app.py
@c:/Py/DS_Viz_SL/scripts/interactive_tool.py (lines 336-381 for chart creation, lines 920-1007 for update callback)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build performance chart and restructure layout</name>
  <files>streamlit_app/streamlit_app.py</files>
  <action>
Modify streamlit_app.py to add the performance chart and restructure the page layout. The changes are:

**1. Add two new session state variables** (after the existing selected_point_idx init):
- `selected_participant` (default None) -- tracks which participant is focused
- `last_clicked_chart` (default None) -- tracks whether 'scatter' or 'performance' was last clicked

**2. Build the performance chart figure (fig_perf)** after the existing scatter figure construction. Follow the original Dash app pattern (interactive_tool.py lines 338-381):
- Create `fig_perf = go.Figure()`
- Add vertical dashed line at x=5.5 (default position, will be updated based on selection): `fig_perf.add_vline(x=5.5, line_width=2, line_dash="dash", line_color="darkgrey")`
- Loop over `metadata['participant_ids'][1:31]` (P_001 through P_030, skip GALL at index 0) to add 30 traces
- For each participant: filter df by OriginalID_PT, sort by OriginalID_Sol, build x_vals as `list(range(1, len(pt_data)+1))` (1-based), y_vals from 'performance' column, get color from first row's 'HEX-Win', get symbols from 'clust_symb' column
- Each trace: `go.Scatter(x=x_vals, y=y_vals, mode='lines+markers', name=pt_id, opacity=0.7, line=dict(color=color), marker=dict(size=7, color=color, symbol=symbols, line=dict(color=color, width=0)))`
- Add horizontal reference line: `fig_perf.add_hline(y=1, line_width=2, line_dash="dot", line_color="black")`
- Layout: `height=300, margin=dict(l=5, r=5, b=5, t=5, pad=2), xaxis=dict(tickmode='linear', dtick=1), showlegend=False, paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor='white'`

**3. Apply selection state to performance chart** (after building fig_perf, before rendering):
If `st.session_state.selected_participant` is not None:
- If participant is 'GALL': hide all 30 traces (`trace.visible = 'legendonly'`), move vline to x=0
- Otherwise:
  - Find trace index: `participant_ids.index(selected_participant)` where participant_ids = metadata['participant_ids'][1:31]
  - Hide all traces except selected: loop over fig_perf.data, set visible=True for matching index, 'legendonly' for others
  - Calculate intervention x: count Pre solutions for that participant, set intervention_x = num_pre + 0.5
  - Update vline position: `fig_perf.layout.shapes[0].x0 = intervention_x`, same for x1
  - Get clicked solution number: `df.iloc[selected_point_idx]['OriginalID_Sol']`, convert to 0-based: `sol_index = int(sol_num - 1)`
  - Build per-point marker arrays for the visible trace: sizes (14 for selected, 8 otherwise), line widths (2 for selected, 0 otherwise)
  - Apply to trace: `fig_perf.data[selected_trace_idx].marker.size = marker_sizes` and `.marker.line.width = marker_line_widths`

**4. Restructure layout** from current two-column (chart | detail) to stacked charts + detail:
- Keep the same `col_charts, col_detail = st.columns([2, 1])` ratio
- Inside col_charts: render scatter plot via plotly_events (existing), then st.write("") spacer, then performance chart via plotly_events (new)
- Inside col_detail: keep existing detail panel code unchanged
- The scatter plotly_events call stays exactly the same but key it explicitly: `key="scatter_chart"`
- The performance plotly_events call: `plotly_events(fig_perf, click_event=True, select_event=False, hover_event=False, override_height=300, override_width="100%", key="perf_chart")`

Do NOT change the click handling logic yet -- that is Task 2. For now, only the scatter click handler from Phase 2 remains. The performance chart is rendered but clicks are not processed yet.
  </action>
  <verify>
Run the Streamlit app locally: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -m streamlit run streamlit_app/streamlit_app.py --server.headless true` -- app should start without errors. Check the terminal output for import errors or runtime exceptions. Also verify the file has no Python syntax errors: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -c "import ast; ast.parse(open('streamlit_app/streamlit_app.py').read()); print('Syntax OK')"`.
  </verify>
  <done>
Performance chart renders below scatter plot with 30 participant traces as lines+markers, horizontal reference line at y=1, vertical dashed intervention line. Clicking scatter point still works (highlights point, shows details) AND now also isolates the clicked participant's trace in the performance chart with intervention line at correct position and highlighted solution marker. GALL clicks hide all performance traces.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement bidirectional click synchronization</name>
  <files>streamlit_app/streamlit_app.py</files>
  <action>
Update the click handling section in streamlit_app.py to support bidirectional clicks between scatter and performance charts.

**1. Replace the existing scatter-only click handler** with dual-chart click detection. The pattern: after both plotly_events calls have been made (scatter_clicks and perf_clicks), process whichever is non-empty:

```python
# Store the plotly_events return values (already done in Task 1)
# scatter_clicks = plotly_events(fig_scatter, ...)
# perf_clicks = plotly_events(fig_perf, ...)

if scatter_clicks:
    clicked_idx = scatter_clicks[0]['pointIndex']
    if clicked_idx != st.session_state.selected_point_idx:
        st.session_state.selected_point_idx = clicked_idx
        st.session_state.selected_participant = df.iloc[clicked_idx]['OriginalID_PT']
        st.session_state.last_clicked_chart = 'scatter'
        st.rerun()

elif perf_clicks:
    curve_num = perf_clicks[0]['curveNumber']
    point_x = perf_clicks[0]['x']

    # Map curveNumber (0-29) to participant ID
    # Performance chart has 30 traces for P_001-P_030 (GALL excluded)
    participant_ids = metadata['participant_ids'][1:31]
    clicked_participant = participant_ids[curve_num]

    # Find the corresponding row in df
    # point_x is the 1-based solution number (x-axis value)
    match = df[(df['OriginalID_PT'] == clicked_participant) &
               (df['OriginalID_Sol'] == point_x)]
    if len(match) > 0:
        solution_idx = match.index[0]
        if solution_idx != st.session_state.selected_point_idx:
            st.session_state.selected_point_idx = solution_idx
            st.session_state.selected_participant = clicked_participant
            st.session_state.last_clicked_chart = 'performance'
            st.rerun()
```

**2. Update the existing scatter click handler** to also set `selected_participant`:
The current handler only sets `selected_point_idx`. It must now also set `selected_participant = df.iloc[clicked_idx]['OriginalID_PT']` and `last_clicked_chart = 'scatter'` before calling st.rerun().

**3. Critical index mapping notes** (from research, matching original Dash app):
- `curveNumber` from perf_clicks maps directly to participant_ids[1:31] (0=P_001, 1=P_002, ..., 29=P_030)
- `x` from perf_clicks is the 1-based solution number matching OriginalID_Sol
- `pointIndex` from scatter_clicks is the DataFrame row index (already used in Phase 2)
- When converting OriginalID_Sol to marker array index: subtract 1 (OriginalID_Sol is 1-based, arrays are 0-based)

**4. Ensure click processing happens inside col_charts** but AFTER both plotly_events calls have been made. The if/elif block must be placed after both chart renderings so both return values are available.

**Important structural note:** Because Streamlit executes top-to-bottom and plotly_events must be called during rendering (inside the column context), the click handling code should be placed right after the perf_clicks assignment, still within the `with col_charts:` block. Both scatter_clicks and perf_clicks are available at that point.
  </action>
  <verify>
Run syntax check: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -c "import ast; ast.parse(open('streamlit_app/streamlit_app.py').read()); print('Syntax OK')"`. Also run the app briefly to confirm no runtime errors: `/c/Users/e_par/miniconda3/condabin/conda.bat run -n DS_312 python -m streamlit run streamlit_app/streamlit_app.py --server.headless true` and check for startup errors in terminal output.
  </verify>
  <done>
Clicking a scatter point: highlights point in scatter (existing), isolates participant trace in performance chart with highlighted solution marker and intervention line, updates detail panel. Clicking a performance chart point: highlights corresponding solution in scatter plot, keeps that participant's trace isolated in performance chart, updates detail panel. Both charts and detail panel stay synchronized regardless of which chart is clicked. GALL scatter clicks hide all performance traces.
  </done>
</task>

</tasks>

<verification>
1. App starts without errors: `python -m streamlit run streamlit_app/streamlit_app.py`
2. Performance chart visible below scatter plot with 30 colored traces
3. Horizontal dotted line at y=1 visible
4. Scatter click highlights point AND isolates participant in performance chart
5. Performance chart click highlights corresponding scatter point AND updates detail panel
6. GALL point click hides all performance traces
7. Intervention line moves to correct pre/post boundary per participant
8. Selected solution marker enlarged (size 14) in performance chart
</verification>

<success_criteria>
- Performance chart renders with 30 participant traces (lines+markers) colored per participant
- Bidirectional click sync: scatter click updates performance chart, performance click updates scatter
- Detail panel updates from either chart click
- Intervention line (vertical dashed) at pre/post boundary for selected participant
- Reference line (horizontal dotted) at y=1
- GALL clicks gracefully hide all performance traces
- No regressions: existing scatter highlighting and detail panel continue to work
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-chart-cross-chart-sync/04-01-SUMMARY.md`
</output>
